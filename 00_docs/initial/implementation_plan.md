# План итеративной разработки

## Анализ зависимостей

```
Граф зависимостей (→ означает "требует"):

UA.dialogue → PC.1
UA.notify → PC.2, DB.processed
DBD → PC.1 → DB.raw
PL (APL) → DB.raw → DB.processed
VS → DB (все топики)
SIM → UA
```

**Центральный узел:** DB — через него проходят все потоки данных.

---

## Итерация 0: Инфраструктурный фундамент

**Модули:** DB (базовая реализация)

**Что делаем:**
- Pub/sub механизм с персистентностью
- Три топика: DB.raw, DB.processed, DB.outbound
- API для публикации и подписки
- Базовая структура сообщений (envelope: timestamp, source, payload)

**Почему первым:**
DB — единственный модуль без входящих зависимостей. Всё остальное либо пишет в DB, либо читает из DB.

**Как тестируем:**
- Unit-тесты pub/sub
- Ручная публикация тестовых сообщений через API/CLI
- Проверка персистентности после перезапуска

**Результат:** работающая шина, готовая принимать данные.

---

## Итерация 1: Наблюдаемость

**Модули:** VS.bus, VS.timeline (базовые версии)

**Что делаем:**
- VS.bus: отображение текущего состояния всех топиков DB
- VS.timeline: swimlanes с ручной публикацией событий (пока без реальных пользователей)

**Почему сейчас:**
Без визуализации дальнейшая разработка — работа вслепую. VS позволяет видеть, что происходит в системе, до появления реальной логики.

**Как тестируем:**
- Публикуем тестовые события в DB через API
- Наблюдаем их появление в VS.bus
- Проверяем корректность отображения на timeline

**Результат:** можем видеть любые данные, попадающие в шину.

---

## Итерация 2: Контекст пользователя

**Модули:** PC (все компоненты)

**Что делаем:**
- PC.1: Dialogue Buffer с метками времени
- PC.2: структура для Dialogue History + Outbound Log
- PC.3: User Profile (пока статичный, без динамического формирования)
- CRUD API для всех компонентов

**Почему сейчас:**
PC — зависимость для UA и DBD. Без контекста невозможно ни вести диалог, ни определять его границы.

**Как тестируем:**
- Ручное добавление сообщений в PC.1
- Проверка записи/чтения резюме в PC.2
- VS.user (добавляем): отображение состояния PC конкретного пользователя

**Результат:** хранилище контекста, готовое к использованию.

---

## Итерация 3: Граница диалога

**Модули:** DBD (варианты 1 и 3 — без LLM)

**Что делаем:**
- Мониторинг PC.1
- Триггер по явному маркеру («всё, спасибо», «готово»)
- Триггер по таймауту (настраиваемый параметр N минут)
- Упаковка диалога → DB.raw
- Формирование резюме → PC.2 (пока простое — последние N сообщений или ключевые фразы)

**Почему сейчас:**
DBD замыкает цепочку PC → DB. После этой итерации данные начинают автоматически попадать в шину.

**Как тестируем:**
- Добавляем сообщения в PC.1 вручную
- Добавляем маркер завершения — проверяем появление в DB.raw
- Ждём таймаут — проверяем появление в DB.raw
- VS.timeline показывает момент срабатывания DBD

**Результат:** диалоги автоматически упаковываются и попадают в шину.

---

## Итерация 4: Симуляция (базовая)

**Модули:** SIM.profiles, SIM.engine (минимальные версии)

**Что делаем:**
- 3-5 захардкоженных профилей (разные роли: менеджер, разработчик, дизайнер)
- SIM.engine: профиль → случайное сообщение из заготовленного пула
- Интеграция: SIM → PC.1 (имитация ввода пользователя)

**Почему сейчас:**
Без SIM приходится вручную вбивать тестовые данные. SIM позволяет генерировать поток сообщений для проверки всей цепочки.

**Как тестируем:**
- Запускаем SIM для одного профиля
- Наблюдаем в VS: сообщения появляются в PC.1 → срабатывает DBD → данные в DB.raw
- Проверяем качество: сообщения содержат конкретику (имена, сроки)

**Результат:** автоматическая генерация тестовых данных, полный цикл до DB.raw работает.

---

## Итерация 5: Первый агент обработки

**Модули:** PL (один APL — например, Entity Extractor)

**Что делаем:**
- APL подписывается на DB.raw
- Извлекает сущности: люди, даты, задачи, проблемы
- Публикует структурированный результат в DB.processed
- Собственная персистентная память для накопления контекста

**Почему сейчас:**
PL — ключевая бизнес-логика. Один агент достаточен для проверки архитектуры: подписка работает, обработка происходит, результат публикуется.

**Как тестируем:**
- SIM генерирует поток сообщений
- Наблюдаем в VS.timeline: DB.raw → APL → DB.processed
- VS.object (добавляем): трассировка конкретной сущности через систему
- Проверяем качество извлечения на известных примерах

**Результат:** данные обрабатываются, структурированная информация появляется в DB.processed.

---

## Итерация 6: Уведомления

**Модули:** UA.notify

**Что делаем:**
- Подписка на DB.processed
- Логика маршрутизации: кому доставить (на основе PC.3 — роль, интересы)
- Семантическая дедупликация через PC.2 (Outbound Log)
- Публикация в DB.outbound

**Почему сейчас:**
Замыкаем обратный поток: система → пользователь. После этого работает полный цикл передачи информации между пользователями.

**Как тестируем:**
- SIM: User A генерирует сообщение с релевантной для User B информацией
- Наблюдаем в VS.timeline: DB.processed → UA.notify → DB.outbound
- Проверяем: User B получил уведомление, User A — нет (избежание эха)
- Дедупликация: повторное сообщение не приводит к повторному уведомлению

**Результат:** межпользовательский поток работает полностью.

---

## Итерация 7: Симуляция (полная)

**Модули:** SIM.seed, SIM.gen, SIM.scenario

**Что делаем:**
- SIM.seed: импорт реального чата для извлечения паттернов
- SIM.gen: генерация новых профилей + фильтрация generic
- SIM.scenario: события внешнего мира как триггеры
- Интеграция: событие + профиль + история → реалистичное сообщение

**Почему сейчас:**
Базовая симуляция работает, но сообщения однообразны. Полноценный SIM нужен для нагрузочного тестирования и демо.

**Как тестируем:**
- Загружаем реальный чат в SIM.seed
- Генерируем 10+ профилей через SIM.gen
- Запускаем сценарий на 30 минут симулированного времени
- Оцениваем качество: конкретика, разнообразие, отсутствие generic

**Результат:** реалистичная симуляция командной работы.

---

## Итерация 8: Визуализация (полная)

**Модули:** VS.flow, улучшения VS.timeline

**Что делаем:**
- VS.flow: анимированный граф для демо (пользователи по краям, DB в центре, частицы)
- VS.timeline: фильтры, поиск, drill-down
- Экспорт данных для анализа

**Почему сейчас:**
Ядро работает, нужна polish для демонстрации. VS.flow — ключевой визуал для лендинга.

**Как тестируем:**
- Запускаем SIM, наблюдаем VS.flow
- Проверяем: механика «схватывается за 3-5 секунд»
- Тестируем на незнакомых с системой людях

**Результат:** демо-ready визуализация.

---

## Итерация 9: Диалоговый интерфейс

**Модули:** UA.dialogue

**Что делаем:**
- Ведение диалога с пользователем (интерфейс-агностик — API)
- Интеграция с PC.1 (запись), PC.2 и PC.3 (чтение для контекста)
- Доставка уведомлений из DB.outbound

**Почему сейчас:**
Вся внутренняя логика отлажена на симуляции. Теперь можно подключать реальный интерфейс.

**Как тестируем:**
- Тестовый клиент (CLI или простой веб)
- Диалог → проверяем появление в VS
- Получение уведомлений от действий другого тестового пользователя

**Результат:** API готов для подключения фронтендов.

---

## Итерации 10+: Фронтенды и расширение

- Telegram-бот
- Мобильное/веб-приложение
- Дополнительные APL-агенты
- Улучшение DBD (возможно, с LLM)
- Динамическое формирование PC.3

---

## Сводная таблица

| Итерация | Модули | Ключевой результат | Зависит от |
|----------|--------|-------------------|------------|
| 0 | DB | Работающая шина | — |
| 1 | VS.bus, VS.timeline | Наблюдаемость | 0 |
| 2 | PC | Хранение контекста | 0 |
| 3 | DBD | Автоупаковка диалогов | 0, 2 |
| 4 | SIM (базовый) | Автогенерация данных | 2, 3 |
| 5 | PL (первый APL) | Обработка данных | 0, 3, 4 |
| 6 | UA.notify | Межпользовательский поток | 0, 2, 5 |
| 7 | SIM (полный) | Реалистичная симуляция | 4, 6 |
| 8 | VS (полный) | Демо-визуализация | 1, 7 |
| 9 | UA.dialogue | API для фронтендов | 2, 6 |

---

## Критический путь

```
DB → PC → DBD → SIM(базовый) → PL → UA.notify
```

Эти модули определяют минимальное время до работающего межпользовательского потока. Параллельно с этим путём можно развивать VS (после итерации 0).

# Сервис коллективной работы на базе AI

## Системное описание и требования

---

## 1. Введение

### 1.1 Проблема

Существующие инструменты командной работы (Trello, Teamly, task trackers) требуют от пользователей адаптации к заданным онтологиям: проекты, задачи, workflow, доски. Это создаёт трение между реальной работой и инструментом. Люди устают от необходимости «жить» в очередной системе и часто откатываются к примитивным средствам (Google Docs, чаты).

### 1.2 Решение

Инверсия модели: не человек адаптируется к инструменту, а инструмент формируется вокруг естественных коммуникаций. Каждый участник команды взаимодействует со своим AI-ассистентом (голос, текст, Telegram, приложение). Ассистенты обмениваются информацией через общую шину данных. Структуры (задачи, сроки, связи) формируются автоматически средствами AI.

### 1.3 Ключевые принципы

- **Минимальный порог входа** — взаимодействие через естественный диалог
- **Онтология формируется под команду** — не команда под онтологию
- **Традиционный интерфейс — второй слой** — веб-интерфейс для систематизации доступен, но не обязателен

### 1.4 Стратегия разработки

Сначала — ядро системы и визуализация для отладки. Фронтенд для пользователей (Telegram-бот, приложение) — после того, как логика ядра отлажена и проверена на симуляции с виртуальными пользователями.

Цель такого подхода: избежать ситуации, когда много сил уходит на интерфейс, а внутренняя логика остаётся непроверенной и непрозрачной.

---

## 2. Архитектура

### 2.1 Модули верхнего уровня

**Ядро (production):**

| Тикер | Название | Назначение |
|-------|----------|------------|
| UA | User Assistant | Ведение диалога с пользователем, доставка уведомлений |
| PC | Personal Context | Контекст пользователя: буфер диалога, история, профиль |
| DBD | Dialogue Boundary Detector | Определение момента упаковки диалога в шину |
| DB | Data Bus | Общая шина данных команды (pub/sub + хранение) |
| PL | Processing Layer | Агенты обработки данных |

**Тестирование и наблюдение:**

| Тикер | Название | Назначение |
|-------|----------|------------|
| SIM | Simulation Layer | Эмуляция пользователей для тестирования |
| VS | Visualization Service | Визуализация для отладки и демо |

### 2.2 Схема ядра

```
UA <--> PC --> DBD --> DB <--> PL
```

### 2.3 Схема тестирования

```
SIM --> UA
DB --> VS
```

---

## 3. Описание модулей

### 3.1 UA — User Assistant

Композитный модуль с изолированными подагентами.

| Подмодуль | Назначение |
|-----------|------------|
| UA.dialogue | Ведёт диалог с пользователем, работает с PC.1 |
| UA.notify | Читает DB.outbound, фильтрует через PC.2, семантическая дедупликация |

**Требования:**
- Подагенты имеют изолированные контексты (разные промпты, минимально необходимые данные)
- UA.notify фильтрует исходящие сообщения через историю доставки (PC.2), чтобы избежать семантического дублирования
- Обратная связь от PL к UA не предусмотрена (Вариант 3 — PL работает только с тем, что есть)

### 3.2 PC — Personal Context

Один экземпляр на каждого пользователя.

| Компонент | Содержимое |
|-----------|------------|
| PC.1 | Dialogue Buffer — текущий открытый диалог (ещё не упакован). Метки времени сообщений. |
| PC.2 | Dialogue History — резюме завершённых диалогов (по предмету, не «ты сказал — я ответил»). Outbound Log — лог доставленных пользователю сообщений. |
| PC.3 | User Profile — роль в команде, текущий фокус, выявленные интересы. Формируется динамически. |

**Требования:**
- Резюме в PC.2 — чистое сжатие по предмету: факты, решения, сроки. Не «ты сказал, я ответил».
- PC.2 хранит и резюме диалогов, и лог исходящих сообщений (единая структура, два типа записей).

### 3.3 DBD — Dialogue Boundary Detector

Мониторит состояние PC.1 и принимает решение об упаковке диалога.

**Триггеры срабатывания (на старте — первые два, без LLM):**
- Явный маркер от пользователя («всё, спасибо»)
- Таймаут (пауза > N минут с момента последнего сообщения)

**Варианты реализации (определяются на этапе разработки):**
1. DBD видит в PC.1 сообщение с явным маркером завершения
2. DBD посылает PC.1 внешнему агенту, который оценивает статус завершения диалога
3. Сервер периодически пингует DBD; тот сравнивает текущее время с временем последнего сообщения в PC.1 и принимает решение

**Результат срабатывания:**
- Упакованный диалог → DB.raw
- Резюме → PC.2

**Известная проблема из прошлого опыта:** детекция завершения диалога — болезненная зона. LLM склонна считать диалог незавершённым. На старте избегаем LLM-анализа для этой задачи.

### 3.4 DB — Data Bus

Pub/sub модель с персистентным хранением. Аналогия — Kafka (и очередь, и хранилище).

**Топики:**

| Топик | Публикует | Подписчики |
|-------|-----------|------------|
| DB.raw | DBD | APL-агенты |
| DB.processed | APL-агенты | UA.notify |
| DB.outbound | UA.notify | UA.dialogue |

**Требования:**
- Персистентность: история нужна для VS, дедупликации, связей между объектами
- Добавление нового APL = регистрация подписки, без изменения остальных модулей
- Если в будущем потребуется обратная связь PL → UA, маршрут через DB

### 3.5 PL — Processing Layer

Набор агентов, обрабатывающих данные в шине.

**Архитектурные принципы:**
- Каждый APL имеет собственную персистентную память
- APL читают весь контекст DB (не только изолированный объект) — это важно для учёта контекста при анализе
- Добавление нового APL = регистрация подписки на топик
- Состав агентов определяется позже, архитектура не ограничивает
- APL не имеют обратного канала к пользователю — работают только с тем, что есть. Неполнота данных помечается, но не запрашивается уточнение.

### 3.6 VS — Visualization Service

**Отладочный режим (MVP):**

| Компонент | Назначение |
|-----------|------------|
| VS.timeline | Swimlanes: дорожки по пользователям, DB в центре, время по горизонтали. Основной вид. |
| VS.object | Трассировка конкретного объекта через систему |
| VS.user | Срез по пользователю: PC.1, PC.2, доставленное |
| VS.bus | Текущее состояние DB |

**Демо-режим (позже):**

| Компонент | Назначение |
|-----------|------------|
| VS.flow | Анимированный граф: пользователи по краям, DB в центре, анимированные частицы показывают движение информации. Схватывается за 3-5 секунд. |

**Требования:**
- VS.timeline (swimlanes) показывает, как событие у User A порождает объект в DB, который затем «всплывает» у User B. Это ключевая визуализация механики сервиса.
- VS должна работать без реальных пользователей — на данных от SIM.
- VS.flow предназначена для лендинга и демо потенциальным клиентам.

### 3.7 SIM — Simulation Layer

Эмуляция пользователей для тестирования и демонстрации.

| Компонент | Назначение |
|-----------|------------|
| SIM.seed | Реальный чат как источник паттернов коммуникации (затравка) |
| SIM.gen | Генерация профилей и сценариев + фильтрация generic + усложнение |
| SIM.profiles | Детальные профили: роль, характер, зона ответственности, стиль коммуникации, типичные проблемы |
| SIM.scenario | События внешнего мира как триггеры для сообщений |
| SIM.engine | Генератор: профиль + событие + история → сообщение |

**Требования:**
- Качество сообщений: ≥ 2-3 конкретных факта (имена, сроки, суммы) + эмоциональная окраска или проблема
- Фильтрация generic: «Обсудили задачу, всё хорошо» — отбраковка
- Пример хорошего сообщения: «Иван из закупок сообщил об отставании поставки X на 2 недели, конфликт с логистикой обострился»
- SIM.seed — можно использовать выгрузку реального рабочего чата для извлечения паттернов

---

## 4. Ключевые потоки данных

### 4.1 От пользователя в систему

```
Пользователь → UA.dialogue → PC.1 → DBD → DB.raw → APL → DB.processed
```

### 4.2 От системы к пользователю

```
DB.processed → UA.notify → DB.outbound → UA.dialogue → Пользователь
```

При этом UA.notify фильтрует через PC.2 для дедупликации.

### 4.3 Межпользовательский поток

User A сообщает → DB.raw → APL обрабатывает → DB.processed → UA.notify решает уведомить User B → DB.outbound → User B получает

---

## 5. Принятые архитектурные решения

| Решение | Обоснование |
|---------|-------------|
| PL не имеет обратного канала к пользователю | Минимальная связность; не усугубляет проблему детекции завершения диалога; неполнота данных — нормальное состояние |
| UA — композитный модуль | Изоляция контекстов подагентов; избежание избыточного контекста, снижающего качество работы |
| DBD без LLM на старте | Известная проблема: LLM склонна не завершать диалог. Таймаут + маркер проще отладить |
| DB как pub/sub с персистентностью | Добавление агентов без изменения архитектуры; история для VS и дедупликации |
| Сначала ядро + VS, потом фронтенд | Избежать потери фокуса на логике; возможность убедиться в корректности до разработки UI |

---

## 6. Открытые вопросы

- Конкретный состав APL-агентов (определяется позже)
- Реализация DBD (один из трёх вариантов)
- Протокол взаимодействия APL с DB (детализация)
- Структура данных в топиках DB (детализация)
- Технологический стек

---

## 7. Сводная карта модулей

| Тикер | Модуль | Подмодули / Компоненты |
|-------|--------|------------------------|
| UA | User Assistant | UA.dialogue, UA.notify |
| PC | Personal Context | PC.1, PC.2, PC.3 |
| DBD | Dialogue Boundary Detector | — |
| DB | Data Bus | DB.raw, DB.processed, DB.outbound |
| PL | Processing Layer | APL1...APLn (каждый со своей памятью) |
| VS | Visualization Service | VS.timeline, VS.object, VS.user, VS.bus, VS.flow |
| SIM | Simulation Layer | SIM.seed, SIM.gen, SIM.profiles, SIM.scenario, SIM.engine |

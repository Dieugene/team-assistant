# Glossary — Концептуальная модель

> Этот документ фиксирует единый язык проекта.
> Все остальные документы архитектуры ОБЯЗАНЫ использовать термины в том значении,
> которое определено здесь. Если термин не определён — он не может использоваться
> в архитектурных документах без предварительного добавления в глоссарий.
>
> Группировка терминов отражает смысловую близость понятий,
> а не архитектурную иерархию. Структурные отношения между понятиями
> (вложенность, ранг, зависимости) определяются в документах архитектуры.
>
> Управление глоссарием: предполагается выделенная роль (Glossary Agent),
> ответственная за целостность терминологии — принятие новых терминов,
> отклонение избыточных, указание на существующие альтернативы.

---

## 1. Domain — предметная область

### User
Реальный человек, взаимодействующий с системой через естественный диалог.
Каждый User ведёт свой независимый Dialogue с AI-ассистентом.

### Team
Группа Users, работающих в общем контексте.
Система формирует онтологию (структуру задач, связей, приоритетов) вокруг Team,
а не наоборот.

### Dialogue
Непрерывный диалог между одним User и его AI-ассистентом.
Состоит из последовательности Messages. Dialogue ведётся в естественной форме;
структура извлекается из него автоматически.

### Message
Одна реплика внутри Dialogue. Имеет роль (user, assistant, system)
и текстовое содержимое. Message — это единица **пользовательского** общения,
не путать с BusMessage.

---

## 2. Communication — внутренняя коммуникация

### EventBus
Внутренняя шина обмена между компонентами системы.
Реализует паттерн pub/sub с push-моделью: публикация вызывает callback'и подписчиков.
EventBus работает в памяти; персистентность обеспечивается через Storage.

### BusMessage
Единица данных, передаваемая через EventBus.
Содержит Topic, типизированный Payload и метаданные (id, timestamp, source).
BusMessage — это единица **межкомпонентной** коммуникации, не путать с Message.

### Topic
Категория BusMessage в EventBus, определяющая направление потока данных:

- **input** — данные из внешней среды (фрагмент диалога, письмо, документ и т.д.)
- **processed** — результат внутренней обработки, предназначенный для внутреннего потребления
- **output** — результат внутренней обработки, предназначенный для вывода во внешнюю среду

### Payload
Типизированное содержимое BusMessage. Структура Payload определяется контекстом
использования. Например, для input-топика Payload может содержать фрагмент диалога,
для output — содержимое, предназначенное пользователю.

---

## 3. Observability — наблюдаемость

### Trace
Общее понятие: след активности системы, записанный для наблюдения и отладки.
Trace существует параллельно основной логике и не влияет на неё.

### TraceEvent
Единичная запись в Trace. Содержит: тип, временну́ю метку, актор (кто породил),
данные для отображения. Сохраняется в Storage через Tracker.

VS UI использует TraceEvents как источник данных для всех представлений:
Timeline, визуализация диалогов, рассуждения агентов и др.

> **Отложено:** механизм связей между TraceEvents (caused_by / caused).
> При необходимости будет введён через опциональное поле в BusMessage
> или через correlation_id. Решение — по результатам практики.

### Tracker
Понятие, обозначающее функцию создания TraceEvents.
Подписывается на все Topics в EventBus и фиксирует всю активность системы.

Tracker **не фильтрует** — он записывает всё. Фильтрация и выбор
представления — ответственность VS UI на этапе отображения.

---

## 4. Dialogue management — управление диалогом

### DialogueAgent
Понятие, обозначающее функцию управления всеми Dialogues одновременно.
Принимает Messages от Users, взаимодействует с LLMProvider,
управляет DialogueBuffer, публикует данные в EventBus (topic: input).
Также отвечает за физическую доставку output-содержимого пользователям
(по указанию OutputRouter).

### DialogueBuffer
Буфер в памяти, накапливающий Messages текущего Dialogue до момента публикации.
Публикация происходит по таймауту или по завершении смыслового блока.
Содержимое буфера отправляется как Payload в BusMessage (topic: input).

---

## 5. Processing — обработка

### ProcessingAgent
Подключаемый модуль обработки. Подписывается на определённые Topics в EventBus,
обрабатывает входящие BusMessages и публикует результаты.
Примеры: извлечение задач, отслеживание дедлайнов, анализ контекста.

### ProcessingLayer
Совокупность всех ProcessingAgents в системе. Каждый ProcessingAgent работает
независимо; между ними нет прямой коммуникации — только через EventBus.

### ContextAgent
Специализированный ProcessingAgent, отвечающий за формирование
и поддержание общей картины (контекста) по Team.
Может выполнять роль OutputRouter (решение отложено).

### OutputRouter
Роль, отвечающая за предобработку output-потока перед доставкой пользователям.
Решает:
- **Кому** доставить (адресация, если output не имеет явного адресата)
- **Когда** доставить (приоритизация, агрегация)
- **В какой форме** (переформулирование, дедупликация)

Мотивация: практика показала, что прямая доставка output от ProcessingAgents
через DialogueAgent приводит к дублированию и информационному шуму.
Точная реализация определится по результатам практики.

### LLMProvider
Абстракция доступа к языковым моделям. Предоставляет единый интерфейс
для взаимодействия с LLM. Используется как в Dialogue management,
так и в Processing. Детальный контракт — в документах архитектуры.

---

## 6. Persistence — хранение данных

### Storage
Уровень персистентного хранения данных. Хранит Messages, DialogueState,
AgentState и TraceEvents.

### DialogueState
Персистентное состояние Dialogue для одного User.
Используется для восстановления DialogueBuffer при перезапуске системы.

### AgentState
Key-value хранилище персистентного состояния ProcessingAgent.
Каждый агент хранит своё состояние независимо.
Включает в себя SGR-трейсы (логи рассуждений агента) в формате JSON.

---

## 7. Visualization — визуализация

### VS UI
Visualization Service UI — веб-интерфейс для наблюдения за работой системы.
Предназначен для разработчиков (отладка) и стейкхолдеров (демонстрация).
Получает данные через polling API. Не влияет на работу основной системы.

VS UI отображает TraceEvents в различных представлениях:
- Timeline (хронологическая лента)
- Визуализация Dialogues (диалоги пользователей и SIM)
- Рассуждения агентов (SGR-трейсы из AgentState)
- Swimlanes (группировка по акторам)

Фильтрация и выбор представления — на стороне VS UI.
Tracker предоставляет полный поток данных.

### Timeline
Хронологическое представление в VS UI: лента TraceEvents.
Новые записи появляются сверху.

### Swimlane
Дорожка на Timeline, группирующая TraceEvents по актору
(User, конкретный ProcessingAgent и т.д.).

---

## 8. Simulation — симуляция

### SIM
Понятие, обозначающее функцию генерации тестовых данных.
Создаёт VirtualUsers и симулирует их взаимодействие с системой
без участия реальных пользователей.

### VirtualUser
Симулированный User с заданным профилем (стиль общения, роль, поведение).
Генерирует Messages, неотличимые для системы от реальных.

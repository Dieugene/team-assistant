# Передача дел: Architect

**Дата:** 2025-01-24
**Сессия:** team-assistant-architect

## Что сделано
- Создана `00_docs/architecture/overview.md` — архитектура системы
- Создана `00_docs/architecture/visualization.md` — требования к визуализации
- Обновлен `README.md` — актуальное описание проекта
- Проведено обсуждение архитектуры с пользователем
- Проведена ревизия на логические противоречия, документ обновлен

## Текущий статус

Архитектура обновлена после ревизии. Убрана излишняя детализация, оставлены архитектурные решения.

## Ключевые архитектурные решения

### Dialogue & Notify Agents
- **Один инстанс DialogueAgent** управляет всеми диалогами
- Три точки активации: сообщение, таймаут, события Event Bus
- Единая диалоговая политика для Dialogue и Notify
- NotifyAgent использует DialogueAgent для доставки

### Processing Agents
- Подключаемые через интерфейс `IProcessingAgent`
- Агенты сами решают кому что доставить (помечают recipients)
- Сначала рамочная система, потом отдельная ветка разработки агентов

### Event Bus
- Транспортный уровень (коммуникация между модулями)
- Отдельный уровень от Tracking (наблюдаемость для VS UI)

### Storage
- Низкоуровневый универсальный интерфейс
- Repository pattern для бизнес-логики
- State vs Memory vs In-memory cache (разъяснено в документе)

### SGR Integration
- Processing Agents на базе SGR
- Conversation storage для персистентности
- Reasoning traces для VS UI

## Что важно знать преемнику

**Из обсуждения с пользователем:**
- Пользователь подчеркнул разделение уровней абстракции (Event Bus vs Storage)
- Tech Lead не занимается составом Processing Agents — только интерфейс
- SGR Agent Core выбран как база, но архитектурно — "подключаемые агенты"
- SQLite для dev, YDB для prod — не для продакшена сейчас

**После ревизии:**
- Убрана излишняя детализация (конкретные классы, методы, псевдокод)
- Оставлены архитектурные решения (один инстанс vs много, кто работает с Event Bus)
- State vs Memory разъяснено концептуально, без деталей реализации

**Философия проекта:**
- MVP-first: простейшая работающая система
- Observability-first: все действия должны быть видимы в VS UI
- Порты и адаптеры: интерфейсы для замены реализаций

## Следующие шаги

1. → **Tech Lead:** Создать `implementation_plan.md`, `backlog.md`, task briefs
2. → **ADR:** Выбор БД для продакшена (когда станет актуально)
3. → **Architect VS:** Детальная архитектура визуализации (если потребуется)

## Файлы для чтения

- `00_docs/architecture/overview.md` — основная архитектура (обязательно)
- `00_docs/architecture/visualization.md` — требования к VS UI (обязательно)
- `README.md` — общее описание проекта (для контекста)

---

**Для запуска Tech Lead используй промпт ниже:**

```
Ты — Tech Lead (см. .agents/tech-lead.md).

Прочитай:
- .agents/tech-lead.md
- AGENTS.md
- 00_docs/standards/common/*
- 00_docs/standards/tech-lead/*
- 00_docs/architecture/overview.md
- Все ADR из 00_docs/architecture/decision_*.md

Задача: Создай implementation plan, backlog и первые задачи для команды.

Определи порядок реализации модулей, спроектируй интерфейсы, разбей на итерации.
```
